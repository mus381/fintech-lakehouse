# Day 2: Lessons Learned

## Core Concepts Mastered
1. **Type Safety**: STRICT mode prevents silent coercion bugs
2. **Idempotency**: External `txn_id` enables safe retries
3. **Error Classification**: Explicit logging distinguishes duplicates from failures
4. **Constraint Design**: CHECK enforces business rules at write-time

## Key Insights

### Insight 1: STRICT is Non-Negotiable for FinTech
Without STRICT, SQLite allows:
- `'50.00'` (TEXT) in REAL columns → silent conversion
- `'not-a-date'` in timestamp columns → sort failures
- Mixed types in same column → calculation errors

**Decision Rule**: Always use STRICT for financial data. No exceptions.

### Insight 2: INSERT OR IGNORE is a Blunt Instrument
Swallows all errors (duplicates + constraint violations) with no feedback.

**When to use:**
- Idempotency checks (duplicate `txn_id`)

**When NOT to use:**
- Data validation (negative amounts, invalid currency)
- Audit-critical operations (need failure logs)

**Better approach:** Manual try/catch with typed error handling

### Insight 3: Primary Keys ≠ Transaction Identity
`pk` is:
- Internal to database
- Assigned after constraint checks
- Has gaps from rejected inserts

`txn_id` is:
- Generated by client before API call
- Stable across retries
- No gaps (external system controls uniqueness)

**Rule**: Use `pk` for internal ordering; `txn_id` for auditing and idempotency

## What I'd Do Differently Next Time
1. Start with STRICT mode from Day 1 (don't retrofit)
2. Add explicit error logging from the start (don't rely on OR IGNORE)
3. Design `txn_id` format upfront (e.g., `{service}_{date}_{user}_{sequence}`)

## Unanswered Questions (for deeper learning)
1. How do distributed systems generate collision-free `txn_id`? (UUIDs vs sequential?)
2. What happens if two servers insert same `txn_id` simultaneously? (race condition)
3. How long should idempotency keys be cached? (30 days? Forever?)
